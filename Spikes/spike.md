# Project

I'm gonna do a "spike" with all the things I want my game to have. The idea is to think like: 
- *I want a world where I can move around and that has resources.
So to do that I'll think that I need either a way to show only a part of the map and make the rest appear as I move, or how to make those fixed resources draw at a coordinate, and that way I'll have a base to start from with things I know work and meet my needs.*

## World

#### How do I make the world have a size but only show a part to give that feeling that you are in a world where you can move and find things?

Ok, first I think what fits best is a "canvas", it's an html element used to paint graphics, for that you also need JavaScript which is in charge of painting the things you want.

1. First I create the canvas with **`<canvas></canvas>`**
2. And I give it the necessary parameters to start configuring it with JavaScript (important the ID and declaring the width and height, otherwise it puts the default ones which is 300x150).

**It would look like this:**
```html
<canvas id="world" height="400" width="800"></canvas>
```

***Important to declare the width and height in the `<canvas>` element because if you do it with CSS it will give problems, it was one of the first errors I encountered.***

Now there are several things that would be interesting to implement so the world makes more sense than just a blank rectangle. For example I would start by making the world have a grid, basically boxes of a fixed size like a chess board that will help differentiate the parts of the map since moving on a white background is kinda like doing nothing. Then it would be good to paint squares or any simple shape that for now will be the resource ores or trees for example, and lastly make it so we can move around the world we created, so let's go step by step:

### World Grid & DPI Fix

Ok so to start we would have to do the initial canvas config like I said before and from there we continue with JavaScript. 

One big problem I found is that canvas lines look blurry on modern screens because of low DPI. To fix that, I created the `accountForDPI()` function. It gets the `devicePixelRatio` and scales the canvas context so everything looks sharp.

```javascript
function accountForDPI() {
  const dpr = window.devicePixelRatio || 1;
  const rect = world.getBoundingClientRect();
  world.width = rect.width * dpr;
  world.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  // We also translate by 0.5 to align lines to the pixel grid and avoid blur
  ctx.translate(0.5, 0.5); 
  world.style.width = `${rect.width}px`;
  world.style.height = `${rect.height}px`;
}
```

***

## Functional World Grid

Now that we did the basic part (making a simple grid) we need to start pointing this to the game we want, so i think first step would be to make the full grid to be a "world", let me explain it better.

We want that with our mouse we are able to move by clicking and dragging the screen, so we do that by creating a "Viewport". The concept is pretty simple: imagine our world has a size of 5000x5000, but our screen is smaller than that. So instead of drawing everything at once, we just show the space that fits on our screen and we update what we draw when we move.

### Making our fullscreen grid

Ok first we need to adapt the **grid.html** to fit the whole screen so we have to get rid of the fixed size of the canvas and make 2 variables that will get the width and height of your browser windows, this helps so it will work for every screen and browser

Before we used this:
```javascript
const WORLD_WIDTH = parseInt(world.getAttribute("width"));
const WORLD_HEIGHT = parseInt(world.getAttribute("height"));
```

Now we use this:
```javascript
// This gets the size of your window
const width = window.innerWidth;
const height = window.innerHeight;
```

Now we have to get rid of a problem, the flexbox, this was used to center the grid but now we dont want that, we want the grid to fit all the space of the window so we have to make it so there's no margins and scrollbars, we do that with these variables.

```css
  body {
    padding: 0;
    margin: 0;
    overflow: hidden;
  }
```

And for the grid to fit all the screen we need these ones.

```css
  #world {
    /*We deleted the border because on a fullscreen world we dont need it and it will add pixels to every side that we dont want*/
    display: block; /*Deletes the blank space generated by default by the canvas*/
    flex-shrink: 0; /*Makes the grid unshrinkable by the browser*/
    width: 100vw; /*Represent 100% of the viewport width*/
    height: 100vh; /*Represent 100% of the viewport height*/
  }
```

We have to delete the size attributes on the **<Canvas>** element because we want the new values to take the lead so the grid fits all the windows and we have to place those new values in all the functions without that nothing will work

### Moving through the world (Viewport & Zoom)

Now we want to use the "viewport" to make our grid able to move and draw the grid at the same time so it looks like we are moving through a world. 

To achieve this, I implemented a `camera` object and a `zoom` variable. The logic is that the "world" is actually huge (around 5000x5000), but we only see a small "window" of it.

1. **The Camera Transformation**: In the main `draw()` function, the secret is using `ctx.translate()` and `ctx.scale()` before drawing anything else. 
2. **Centering the view**: First, we translate to the center of the screen so that zooming happens from the middle, not the top-left corner.

**It looks like this in the code:**
```javascript
function draw() {
  ctx.setTransform(1, 0, 0, 1, 0, 0); 
  ctx.fillStyle = "#050a14";
  ctx.fillRect(0, 0, world.width, world.height);
  
  const dpr = window.devicePixelRatio || 1;
  ctx.scale(dpr, dpr);

  const viewCX = window.innerWidth / 2 + shakeOffset.x;
  const viewCY = window.innerHeight / 2 + shakeOffset.y;

  ctx.translate(viewCX, viewCY); // Move to screen center
  ctx.scale(zoom, zoom);         // Apply zoom level
  ctx.translate(-camera.x, -camera.y); // Move to camera position

  drawGrid();
  // ... rest of game elements
}
```

***One big problem I found:*** When you apply a zoom, the standard mouse coordinates (`e.clientX`) no longer match the coordinates in your drawing. I had to create a formula to "translate" the screen click back into world coordinates using `viewCX`, `zoom`, and `camera.x/y`. Without this, clicking on a resource while zoomed out was impossible!

### Dragging with Right Click

I decided to use the **Right Mouse Button** for movement to keep the Left Click free for farming. 
- I used `window.addEventListener('mousemove', ...)` to track the delta (difference) between the current mouse position and the last one.
- Then I simply add that delta to the camera coordinates.
- I used `e.preventDefault()` on `contextmenu` so the browser menu doesn't pop up.

```javascript
if (isDragging) {
  camera.x -= (mx - lastMousePos.x) / zoom;
  camera.y -= (my - lastMousePos.y) / zoom;
  lastMousePos = { x: mx, y: my };
}
```

---

## Procedural World Generation (Resource Patches)

Instead of placing every resource by hand, I created an `initWorld()` function that populates the map using distance-based rarity.

- **The logic**: Near the center, you mostly find **Wood**. As you move further away (calculated with `Math.sqrt(x*x + y*y)`), the code starts rolling for rarer materials like **Iron**, **Silver**, and **Gold**.
- **Patches**: To make it look like biomes, I created `createPatch()`. It generates clusters of resources in a grid so they don't look like messy random dots.

---

## The Core: Our Greedy God

In the absolute center `(0,0)`, I placed the **Core**. Itâ€™s a blue circle with a face representing the god we owe everything to.

- **Happiness Animation**: I added a `coreHappyTimer`. When you deliver resources, the mouth changes to a happy smile for a few frames.
- **Reactive UI**: The Core pulses and grows (`coreScale`) when you hover over it or interact with it.

---

## Mission & Panic System

The game is structured into 67 levels. Each mission is a "Demand" from the Core.
- **Panic Mode**: In `style.css`, I created a `pulse-red` animation. When `mission.timeLeft` is below 5 seconds, the UI flashes and the screen shakes to stress the player out.
- **Ready Mode**: If you have enough resources in your inventory to complete the mission, the panel turns blue and starts pulsing to tell you: "GO TO THE CENTER NOW!"

---

## Boss Battles & Minigames

Every 10 levels, a big Boss appears. They have a **Shield Mechanic**: at 66% and 33% HP, they become `immune` and trigger a random minigame.

1. **AIM MAD**: Random targets spawn in world coordinates. You have to click them fast.
2. **WRITING CRAZY**: The boss shows a tech word (like `SYSTEM` or `VOID`). You have to type it perfectly using the keyboard.
3. **DIRECTIONS TO HELL**: The screen is divided into 4 sectors (TOP, BOTTOM, LEFT, RIGHT). One turns green, and you must type that direction.

**Learning:** I added `BOSS_TAUNTS` so the boss insults you with speech bubbles like "TOO SLOW!" to make it feel more intense.

---

## Typing Upgrades

To keep the game keyboard-centric, you choose upgrades by **typing their names** (e.g., typing "STORAGE" or "LUCK").
- **Rarity Engine**: Cards range from Common to Legendary. The `player.luck` stat increases the chance of getting high-rarity cards with better stats.
- **Visuals**: Legendary cards have a golden glow and a shake animation in CSS.

---

## Save & Load System

Since level 67 is a long journey, I needed a persistence system.
- **Exporting**: `exportSave()` converts the `player` object and level into a JSON string and generates a downloadable `.txt` file.
- **Importing**: I use the `FileReader` API to read the text file and restore the player stats and progress instantly.

---

## Final UI & Juice

- **Trash Can**: A vital feature. If your inventory is full of things the god doesn't want, you can **Right-Click** the trash icon to empty it.
- **Floating Text & Particles**: Every action (mining, delivering, taking damage) spawns floating indicators and particles to make the game feel "juicy" and responsive.
- **The Ending**: If you defeat the God at level 67, the game redirects to `ending.html` for the final victory message.
